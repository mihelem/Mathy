using LinearAlgebra
using SparseArrays

# Zeroth Order Methods

# First Order Methods
abstract type DescentMethod end

struct GradientDescent <: DescentMethod
    Œ±
end
init!(M::GradientDescent, f, ‚àáf, x) = M
function step!(M::GradientDescent, f, ‚àáf, x)
    Œ±, g = M.Œ±, ‚àáf(x)
    return x - Œ±*g
end

mutable struct ConjugateGradientDescent <: DescentMethod
    d
    g
end
function init!(M::ConjugateGradientDescent, f, ‚àáf, x)
    M.g = ‚àáf(x)
    M.d = -M.g
    return M
end
# mmh...
function step!(M::ConjugateGradientDescent, f, ‚àáf, x, line_search)
    d, g = M.d, M.g
    g‚Ä≤= ‚àáf(x)

    # If we knew an approximating quadratics, it would be
    # Œ≤ = (g‚Ä≤‚ãÖ‚àá‚àáf*d) / (d‚ãÖ‚àá‚àáf*d)
    # Fletcher-Reeves
    # Œ≤ = g‚Ä≤‚ãÖg‚Ä≤ / g‚ãÖg
    # Polak-Ribi√®re
    Œ≤ = max(0, g‚Ä≤‚ãÖ(g‚Ä≤-g) / g‚ãÖg)
    d‚Ä≤ = -g‚Ä≤ + Œ≤*d
    x‚Ä≤ = line_search(f, x, d‚Ä≤)
    M.d, M.g = d‚Ä≤, g‚Ä≤
    return x‚Ä≤
end

mutable struct MomentumDescent <: DescentMethod
    Œ±   # learning rate
    Œ≤   # momentum decay
    v   # momentum
end
function init!(M::MomentumDescent, f, ‚àáf, x)
    M.v = zeros(length(x))
    return M
end
function step!(M::MomentumDescent, f, ‚àáf, x)
    Œ±, Œ≤, v, g = M.Œ±, M.Œ≤, M.v, ‚àáf(x)
    v[:] = Œ≤*v - Œ±*g
    return x+v
end

mutable struct NesterovMomentumDescent <: DescentMethod
    Œ± # learning rate
    Œ≤ # momentum decay
    v # momentum
end
function init!(M::NesterovMomentumDescent, f, ‚àáf, x)
    Œ±, Œ≤, v = M.Œ±, M.Œ≤, M.v
    v[:] = Œ≤*v - Œ±*‚àáf(x + Œ≤*v)
    return x+v
end

mutable struct AdagradDescent <: DescentMethod
    Œ± # learning rate
    œµ # small value
    s # sum of squared gradient 
end
function init!(M::AdagradDescent, f, ‚àáf, x)
    M.s = zeros(length(x))
    return M
end
function step!(M::AdagradDescent, f, ‚àáf, x)
    Œ±, œµ, s, g = M.Œ±, M.œµ, M.s, ‚àáf(x)
    s[:] += g .* g
    return x - Œ±*g ./ (sqrt.(s) .+ œµ)
end

mutable struct RMSPropDescent <: DescentMethod
    Œ± # learning rate
    Œ≥ # decay
    œµ # small value
    s # sum of squared gradient
end
function init!(M::RMSPropDescent, f, ‚àáf, x)
    M.s = zeros(length(x))
    return M
end
function step!(M::RMSPropDescent, f, ‚àáf, x)
    Œ±, Œ≥, œµ, s, g = M.Œ±, M.Œ≥, M.œµ, M.s, ‚àáf(x)
    s[:] = Œ≥*s + (1-Œ≥)*(g .* g)
    return x - Œ±*g ./ (sqrt.(s) .+ œµ)
end

mutable struct AdadeltaDescent <: DescentMethod
    Œ≥s # gradient decay
    Œ≥x # update decay
    œµ # small value
    s # sum of squared gradients
    u # sum od squared gradients
end
function init!(M::AdadeltaDescent, f, ‚àáf, x)
    M.s = zeros(length(x))
    M.u = zeros(length(x))
    return M
end
function step!(M::AdadeltaDescent, f, ‚àáf, x)
    Œ≥s, Œ≥x, œµ, s, u, g = M.Œ≥s, M.Œ≥x, M.œµ, M.s, M.u, ‚àáf(x)
    s[:] = Œ≥s*s + (1-Œ≥s)*g.*g
    Œîx = - (sqrt.(u) .+ œµ) ./ (sqrt.(s) .+ œµ) .* g
    u[:] = Œ≥x*u + (1-Œ≥x)*Œîx.*Œîx
    return x+Œîx
end

mutable struct AdamDescent <: DescentMethod
    Œ± # learning rate
    Œ≥v # decay
    Œ≥s # decay
    œµ # small value
    k # step counter
    v # 1st moment estimate
    s # 2nd moment estimate
end
function init!(M::AdamDescent, f, ‚àáf, x)
    M.k = 0
    M.v = zeros(length(x))
    M.s = zeros(length(x))
    return M
end
function step!(M::AdamDescent, f, ‚àáf, x)
    Œ±, Œ≥v, Œ≥s, œµ, k = M.Œ±, M.Œ≥v, M.Œ≥s, M.œµ, M.k
    s, v, g = M.s, M.v, ‚àáf(x)
    v[:] = Œ≥v*v + (1-Œ≥v)*g
    s[:] = Œ≥s*s + (1-Œ≥s)*g.*g
    M.k = k += 1
    vÃÇ = v ./ (1 - Œ≥v^k)
    sÃÇ = s ./ (1 - Œ≥s^k)
    return x - Œ±*vÃÇ ./ (sqrt.(sÃÇ) .+ œµ)
end

mutable struct HyperGradientDescent <: DescentMethod
    Œ±‚ÇÄ # initial learning rate
    ¬µ # learning rate of the learning rate
    Œ± # current learning rate
    g_prev # previous gradient
end
function init!(M::HyperGradientDescent, f, ‚àáf, x)
    M.Œ± = M.Œ±‚ÇÄ
    M.g_prev = zeros(length(x))
    return M
end
function step!(M::HyperGradientDescent, f, ‚àáf, x)
    Œ±, ¬µ, g, g_prev = M.Œ±, M.¬µ, ‚àáf(x), M.g_prev
    Œ± = Œ± + ¬µ*(g‚ãÖg_prev)
    M.g_prev, M.Œ± = g, Œ±
    return x - Œ±*g
end

mutable struct HyperNesterovMomentumDescent <: DescentMethod
    Œ±‚ÇÄ # initila learning rate
    ¬µ # learning rate of the learning rate
    Œ≤ # momentum decay
    v # momentum
    Œ± # current learning rate
    g_prev # previous gradient
end
function init!(M::HyperNesterovMomentumDescent, f, ‚àáf, x)
    M.Œ± = M.Œ±‚ÇÄ
    M.v = zeros(length(x))
    M.g_prev = zeros(length(x))
    return M
end
function step!(M::HyperNesterovMomentumDescent, f, ‚àáf, x)
    Œ±, Œ≤, ¬µ = M.Œ±, M.Œ≤, M.¬µ
    v, g, g_prev = M.v, ‚àáf(x), M.g_prev
    Œ± = Œ± - ¬µ*(g‚ãÖ(-g_prev - Œ≤*v))
    v[:] = Œ≤*v + g
    M.g_prev, M.Œ± = g, Œ±
    return x - Œ±*(g + Œ≤*v)
end

mutable struct NoisyDescent <: DescentMethod
    submethod
    œÉ
    k
end
function init!(M::NoisyDescent, f, ‚àáf, x)
    init!(M.submethod, f, ‚àáf, x)
    M.k = 1
    return M
end
function step!(M::NoisyDescent,f, ‚àáf, x)
    x = step!(M.submethod, f, ‚àáf, x)
    œÉ = M.œÉ(M.k)
    x += œÉ.*randn(length(x))
    M.k += 1
    return x
end


# usage:
# ùîì = generate_quadratic_min_cost_flow_boxed_problem(Float64, 10, 20)
# L, x, Œº, ‚àáL = solve_quadratic_min_flow(ùîì=ùîì, Œº=zeros(Float64, 10), œµ=1e-6, Œµ=1e-6)

# Problem
# min‚Çì { ¬Ωx·µÄQx + q·µÄx  with  x s.t.  Ex = b  &  l ‚â§ x ‚â§ u }
# Q ‚àà { diag ‚â• 0 }
abstract type min_cost_flow_problem end
abstract type quadratic_min_cost_flow_boxed_problem <: min_cost_flow_problem end
struct unreduced_qmcfbp <: quadratic_min_cost_flow_boxed_problem
    Q
    q
    l
    u
    E
    b
end
struct reduced_qmcfbp <: quadratic_min_cost_flow_boxed_problem
    Q
    q
    l
    u
    E
    b
end

# m : number of vertices
# n : number of edges
function generate_quadratic_min_cost_flow_boxed_problem(type, m, n; sing=0)
    Q = spdiagm(0 => [sort(rand(type, n-sing), rev=true); zeros(type, sing)])
    q = rand(eltype(Q), n)
    E = spzeros(Int8, m, n)
    for i=1:n
        u, v = (rand(1:m), rand(1:m-1))
        v = u==v ? m : v
        E[u, i] = 1
        E[v, i] = -1
    end
    x = rand(eltype(Q), n)
    l = -10*rand(eltype(Q), n)+x
    u = 10*rand(eltype(Q), n)+x
    b = E*x
    return unreduced_qmcfbp(Q, q, l, u, E, b)
end

function noNaN(V)
    return (x -> isnan(x) ? 0. : x).(V)
end

function get_gaussian_pivoted_and_apply(E, M)
    m, n = size(E)
    @views A = [E M]


end

# WIP
# Another Dual
# Equality constrained absorbed by the nullspace method
# dualising box constriants
function solve_quadratic_min_flow_d3(; ùîì, Œª, œµ)
    (Q, q, l, u, E, b) = (ùîì.Q, ùîì.q, ùîì.l, ùîì.u, ùîì.E, ùîì.b)
    
    # Assumption : m ‚â§ n
    function split_eq_constraint(œµ)
        m, n = size(E)
        A = [E b I]
        P‚Çï, P·µ• = [i for i in 1:n], [i for i in 1:m]
        n‚Ä≤ = n
        for i=1:m
            for i‚Ä≤=i:n‚Ä≤
                j = i
                for j‚Ä≤=i:m
                    if abs(A[j‚Ä≤, i‚Ä≤]) > abs(A[j, i‚Ä≤])
                        j = j‚Ä≤
                    end
                end
                if abs(A[j, i‚Ä≤]) > œµ
                    P·µ•[i], P·µ•[j] = P·µ•[j], P·µ•[i]
                    A[i, i‚Ä≤:end], A[j, i‚Ä≤:end] = A[j, i‚Ä≤:end], A[i, i‚Ä≤:end]

                    P‚Çï[i], P‚Çï[i‚Ä≤] = P‚Çï[i‚Ä≤], P‚Çï[i]
                    A[:, i], A[:, i‚Ä≤] = A[:, i‚Ä≤], A[:, i]
                    A[:, i+1:i‚Ä≤], A[:, (n‚Ä≤+i+1-i‚Ä≤):n‚Ä≤] = A[:, (n‚Ä≤+i+1-i‚Ä≤):n‚Ä≤], A[:, i+1:i‚Ä≤]
                    P‚Çï[i+1:i‚Ä≤], P‚Çï[(n‚Ä≤+i+1-i‚Ä≤):n‚Ä≤] = P‚Çï[(n‚Ä≤+i+1-i‚Ä≤):n‚Ä≤], P‚Çï[i+1:i‚Ä≤]

                    n‚Ä≤ = n‚Ä≤+i-i‚Ä≤
                    break
                end
            end
            if abs(A[i, i]) ‚â§ œµ
                break
            end

            A[i+1:end, i:end] -=  (A[i+1:end, i] / A[i, i]) .* A[i, i:end]'
        end

        dimension = m
        for i=m:-1:1
            if abs(A[i, i]) ‚â§ œµ
                dimension -= 1
                continue
            end
            A[i, i:end] ./= A[i, i]
            A[1:i-1, i:end] -= A[1:i-1, i] .* A[i, i:end]'
        end

        return (dimension, P·µ•, P‚Çï, A)
    end

    dimension, P·µ•, P‚Çï, A = split_eq_constraint(œµ)
    m, n = dimension, size(E, 2)-dimension

    @views b_B = b[P·µ•[1:dimension]]
    @views EÃÉ_Bb = A[1:dimension, size(E, 2)+1]
    @views Q_B = Q[P‚Çï[1:dimension], P‚Çï[1:dimension]]
    @views Q_N = Q[P‚Çï[dimension+1:end], P‚Çï[dimension+1:end]]
    @views EÃÉ_BE_N = A[1:dimension, dimension+1:size(E, 2)]
    @views q_B, q_N = q[P‚Çï[1:dimension]], q[P‚Çï[dimension+1:end]]
    ‚àá‚àáL‚ÇÇ = EÃÉ_BE_N'Q_B*EÃÉ_BE_N + Q_N
    ‚àáL‚ÇÅ = q_N - EÃÉ_BE_N'(q_B + Q_B*EÃÉ_Bb)
    L‚ÇÄ = 0.5 * EÃÉ_Bb'Q_B*EÃÉ_Bb + q_B'EÃÉ_Bb




    function test()
        return split_eq_constraint(œµ)
    end

    return test()
end

# WIP 
# TODO: deflected projected subgradients methods + check what's wrong (in the model)
# Dualised constraints: 
# Ex = b
# l ‚â§ x ‚â§ u
function solve_quadratic_min_flow_d2a(; ùîì, ŒΩ, œµ, œµ_C=œµ*100, œµ_Q=0.0)
    # NB: const is still not supported for local variables (er why?)
    (Q, q, l, u, E, b) = (ùîì.Q, ùîì.q, ùîì.l, ùîì.u, ùîì.E, ùîì.b)
    E = eltype(Q).(E)
    (m, n) = size(E)

    # partition subspaces corresponding to ker(Q)
    ‚Ñ≠ = [Q[i, i] > œµ_Q for i in 1:n]
    function partition(v)
        return (v[.~‚Ñ≠], v[‚Ñ≠])
    end
    function partition!(v)
        @views return (v[.~‚Ñ≠], v[‚Ñ≠])
    end
    n‚ÇÅ = count(‚Ñ≠)
    Q‚ÇÅ = Q[‚Ñ≠, ‚Ñ≠]
    QÃÉ‚ÇÅ = spdiagm(0 => [1.0/Q‚ÇÅ[i, i] for i in 1:n‚ÇÅ])
    (E‚ÇÄ, E‚ÇÅ) = E[:, .~‚Ñ≠], E[:, ‚Ñ≠]
    ((q‚ÇÄ, q‚ÇÅ), (l‚ÇÄ, l‚ÇÅ), (u‚ÇÄ, u‚ÇÅ)) = partition.([q, l, u])
    @views (Œº, Œª·µ§, Œª‚Çó) = (ŒΩ[1:m], ŒΩ[m+1:m+n], ŒΩ[m+n+1:m+2n])
    ((Œª·µ§‚ÇÄ, Œª·µ§‚ÇÅ), (Œª‚Çó‚ÇÄ, Œª‚Çó‚ÇÅ)) = partition!.([Œª·µ§, Œª‚Çó])

    # from the singular part of Q we get a linear problem
    # which translates to the equation
    #     Œª‚Çó‚ÇÄ = q‚ÇÄ + Œª·µ§‚ÇÄ + E‚ÇÄ·µÄŒº
    # from which we can remove Œª‚Çó‚ÇÄ from the problem, 
    # keeping the inequality constraints
    #     Œª·µ§‚ÇÄ + E‚ÇÄ·µÄŒº + q‚ÇÄ .‚â• 0
    #     Œª·µ§, Œª‚Çó‚ÇÅ .‚â• 0
    get_Œª‚Çó‚ÇÄ = () -> q‚ÇÄ + E‚ÇÄ'*Œº + Œª·µ§‚ÇÄ
    Œª‚Çó‚ÇÄ[:] = get_Œª‚Çó‚ÇÄ()
    # hence we have ŒΩ·µ£ which is ŒΩ restricted to the free variables
    ŒΩ·µ£ = view(ŒΩ, [[i for i in 1:m+n]; (m+n) .+ findall(‚Ñ≠)])
    ŒΩ‚ÇÅ = view(ŒΩ, [[i for i in 1:m]; m .+ findall(‚Ñ≠); (m+n) .+ findall(‚Ñ≠)])

    # I am minimizing -L(‚Å†ŒΩ), which is
    # ¬Ω(E‚ÇÅ·µÄŒº + Œª·µ§‚ÇÅ - Œª‚Çó‚ÇÅ)·µÄQÃÉ‚ÇÅ(E‚ÇÅ·µÄŒº + Œª·µ§‚ÇÅ - Œª‚Çó‚ÇÅ) ( = ¬ΩŒΩ‚ÇÅ·µÄT‚ÇÅ·µÄQÃÉ‚ÇÅT‚ÇÅŒΩ‚ÇÅ = L‚ÇÇ ) + 
    # q‚ÇÅ·µÄQÃÉ‚ÇÅ(E‚ÇÅ·µÄŒº + Œª·µ§‚ÇÅ - Œª‚Çó‚ÇÅ) + b·µÄŒº + u‚ÇÅ·µÄŒª·µ§‚ÇÅ + (u‚ÇÄ-l‚ÇÄ)·µÄŒª·µ§‚ÇÄ - l‚ÇÄ·µÄE‚ÇÄ·µÄŒº - l‚ÇÅ·µÄŒª‚Çó‚ÇÅ ( = t·µÄŒΩ·µ£ = L‚ÇÅ ) +
    # ¬Ωq‚ÇÅ·µÄQÃÉ‚ÇÅq‚ÇÅ - q‚ÇÄ·µÄl‚ÇÄ ( = L‚ÇÄ )
    L‚ÇÄ = 0.5q‚ÇÅ'*QÃÉ‚ÇÅ*q‚ÇÅ - q‚ÇÄ'*l‚ÇÄ
    ‚àáL‚ÇÅ = begin
        t_Œº = E‚ÇÅ*QÃÉ‚ÇÅ*q‚ÇÅ + b - E‚ÇÄ*l‚ÇÄ
        t_Œª·µ§ = zeros(eltype(t_Œº), n)
        t_Œª·µ§[‚Ñ≠] = QÃÉ‚ÇÅ*q‚ÇÅ + u‚ÇÅ
        t_Œª·µ§[.~(‚Ñ≠)] = u‚ÇÄ - l‚ÇÄ
        t_Œª‚Çó‚ÇÅ = -QÃÉ‚ÇÅ*q‚ÇÅ - l‚ÇÅ
        [t_Œº; t_Œª·µ§; t_Œª‚Çó‚ÇÅ]
    end
    get_L‚ÇÅ = () -> ‚àáL‚ÇÅ'*ŒΩ·µ£
    T‚ÇÅ = begin
        T = [E‚ÇÅ' spzeros(eltype(Q), n‚ÇÅ, n) (-I)]
        T[:, n .+ findall(‚Ñ≠)] = I(n‚ÇÅ)
        T
    end
    ‚àá‚àáL‚ÇÇ = T‚ÇÅ'*QÃÉ‚ÇÅ*T‚ÇÅ
    get_‚àáL = () -> ‚àáL‚ÇÅ + ‚àá‚àáL‚ÇÇ*ŒΩ·µ£
    get_L‚ÇÇ = () -> ( T‚ÇÅ*ŒΩ·µ£ |> (a -> 0.5*a'*QÃÉ‚ÇÅ*a) )
    get_L = () -> L‚ÇÄ + get_L‚ÇÅ() + get_L‚ÇÇ()
    function get_x()
        x = spzeros(n)
        x[‚Ñ≠] = QÃÉ‚ÇÅ*(-q‚ÇÅ - E‚ÇÅ'Œº - Œª·µ§‚ÇÅ + Œª‚Çó‚ÇÅ)
        if count(.~‚Ñ≠)>0
            # try? approximately active... œµ_C ?
            Œª‚Çó‚ÇÄ = get_Œª‚Çó‚ÇÄ()
            active_Œª‚Çó‚ÇÄ = Œª‚Çó‚ÇÄ .> 0
            x[.~‚Ñ≠][active_Œª‚Çó‚ÇÄ] .= l[.~‚Ñ≠][active_Œª‚Çó‚ÇÄ]
            active_Œª·µ§‚ÇÄ = Œª·µ§‚ÇÄ .> 0
            x[.~‚Ñ≠][active_Œª·µ§‚ÇÄ] .= u[.~‚Ñ≠][active_Œª·µ§‚ÇÄ]
            inactive_i = findall(.~‚Ñ≠) |> (P -> [P[i] for i in findall(.~(active_Œª·µ§‚ÇÄ .| active_Œª‚Çó‚ÇÄ))])
            inactive = spzeros(Bool, n) |> (a -> (for i in inactive_i a[i] = true end; a))
            active = .~inactive

            # left inverse not supported for sparse vectors
            if count(inactive)>0
                x[inactive] =  E[:, inactive] \ Array(b - E[:, active]*x[active])
            end
            # TODO: check the above is satisfying the constraints
        end

        return x
    end
    
    function get_Œ±(d)
        function get_constraints()
            # constraints: E‚ÇÄ·µÄŒº + Œª·µ§‚ÇÄ + q‚ÇÄ .‚â• 0   &&   Œª·µ£ .‚â• 0   =>
            #   Œ±*(E‚ÇÄ·µÄ*d_Œº + d_Œª·µ§‚ÇÄ) .‚â• -(E‚ÇÄ·µÄŒº + Œª·µ§‚ÇÄ + q‚ÇÄ)
            #                Œ±*d_Œª·µ£ .‚â• -Œª·µ£
            M = [E‚ÇÄ'd[1:m] + d[m+1:m+n][.~‚Ñ≠]   (-(E‚ÇÄ'Œº + Œª·µ§‚ÇÄ + q‚ÇÄ))]
            M = cat(M, [d[m+1:end]   (-ŒΩ·µ£[m+1:end])], dims=1)

            # (ùî≤, ùî©)  : constraints defining an (upper, lower) bound for Œ±
            ùî≤, ùî© = (M[:, 1] .< 0), (M[:, 1] .> 0)
            C = spzeros(eltype(M), size(M, 1))
            (ùî≤ .| ùî©) |> ùî† -> C[ùî†] = M[ùî†, 2] ./ M[ùî†, 1]

            return (ùî©, ùî≤, C)
        end
        function apply_constraints(Œ±, (ùî©, ùî≤, C))
            Œ±_lb, Œ±_ub = maximum([C[ùî©]; -Inf]), minimum([C[ùî≤]; Inf])
            #if isnan(Œ±)
                # todo: why?
            #end
            #if Œ± + œµ_C*abs(Œ±) < Œ±_lb - œµ_C*abs(Œ±_lb)
            #    println("ERROR: Œ± = $Œ± is less than $Œ±_lb")
            #end
            Œ± = min(max(Œ±, Œ±_lb), Œ±_ub)   
            active_C = zeros(Bool, size(C, 1))
            # leaving a bit of freedom more... shall we do it? 
            Œ±‚Çä, Œ±‚Çã = Œ±*(1+œµ_C*sign(Œ±)), Œ±*(1-œµ_C*sign(Œ±))
            C‚Çä, C‚Çã = C .* (1 .+ œµ_C*sign.(C)), C .* (1. .- œµ_C*sign.(C))
            active_C[ùî≤] = ((Œ±‚Çã .‚â§ C‚Çä[ùî≤]) .& (Œ±‚Çä .‚â• C‚Çã[ùî≤]))

            return (Œ±, active_C)
        end
        
        # ‚àÇL = d'*‚àá‚àáL‚ÇÇ*(ŒΩ·µ£ + Œ±*d) + d'*‚àáL‚ÇÅ => Œ± = -(d'*‚àáL‚ÇÅ + d'*‚àá‚àáL‚ÇÇ*ŒΩ·µ£) / (d'*‚àá‚àáL‚ÇÇ*d)
        # avoid multiple piping for better readability
        Œ± = d'‚àá‚àáL‚ÇÇ |> (a -> - (d'‚àáL‚ÇÅ + a*ŒΩ·µ£) / (a*d))
        ùî©, ùî≤, C = get_constraints()
        return apply_constraints(Œ±, (ùî©, ùî≤, C))
    end

    function solve_by_proj_conj_grad()
        P‚àáL = -get_‚àáL()
        println("|‚àáL| = $(norm(P‚àáL))\tL = $(-get_L())")
        d = copy(P‚àáL)

        # C .‚â• 0 || Œª‚Çó‚ÇÄ .‚â• 0 | Œª·µ£ .‚â• 0 ||
        # ------------------------------ 
        #        || E‚ÇÄ       |    0    ||
        #   ‚àáC   || [.~‚Ñ≠]I   |    I    ||
        #        || 0        |         ||
        # here I'm taking the inward normal since we have feasibility for C .‚â• 0
        # (we shouldn't move along this normal)
        ‚àáC = -[[E‚ÇÄ; (I(n))[:, .~‚Ñ≠]; spzeros(eltype(Q), n‚ÇÅ, n-n‚ÇÅ)]  [spzeros(eltype(Q), m, n+n‚ÇÅ); I(n+n‚ÇÅ)]]

        function project!(M, v)
            if size(M, 2) > 0
                for c in eachcol(M)
                    v·µÄc = v'c
                    if v·µÄc > 0.
                        v[:] = v - c * v·µÄc / (c'c)
                    end
                end
            end
        end
        
        counter = 0
        ‚àáL = copy(P‚àáL)
        ‚àáL‚ÇÄ = copy(‚àáL)
        ŒΩ·µ£‚ÇÄ = copy(ŒΩ·µ£)
        L = -get_L()
        L‚ÇÄ = L
        LÃÑ = L
        while norm(P‚àáL) > œµ
            Œ±, active_C = get_Œ±(d)
            ŒΩ·µ£[:] += Œ±*d

            P‚àáL[:] = -get_‚àáL()

            ‚àáL‚ÇÄ[:] = ‚àáL
            ‚àáL[:] = P‚àáL
            # d[:] = ‚àá‚àáL‚ÇÇ*d |> (Md -> P‚àáL - d * (P‚àáL'*Md) / (d'*Md))
            # d[:] = (counter & 0) != 0 ? (‚àá‚àáL‚ÇÇ*d |> (Md -> P‚àáL - d * (P‚àáL'*Md) / (d'*Md))) : P‚àáL
            d[:] = ‚àáL + d*(‚àáL'*‚àáL - ‚àáL'*‚àáL‚ÇÄ) / (‚àáL‚ÇÄ'*‚àáL‚ÇÄ)
            
            if d'‚àáL < 0.
                d[:] = P‚àáL
            end
            # d[:] = P‚àáL
            #d[:] = d + norm(d)*rand(eltype(d), size(d, 1))*0.2
            project!(view(‚àáC, :, active_C), P‚àáL) 
            project!(view(‚àáC, :, active_C), d)
            # project d onto the feasible space for ŒΩ·µ£
            
            println("|P‚àáL| = $(norm(P‚àáL))\tL = $(-get_L())")

            counter += 1
            if counter > Inf
                break
            end
        end

        x, ‚àáL = get_x(), -get_‚àáL()
        P‚àáL = copy(‚àáL)
        Œ±, active_C = get_Œ±(d)
        project!(view(‚àáC, :, active_C), P‚àáL)
        println("\nŒº = $Œº\nx = $x\n‚àáL = $‚àáL\nP‚àáL = $P‚àáL\nactive_C = $active_C\n\n $counter iterazioni\n")

        Œª‚Çó‚ÇÄ[:] = get_Œª‚Çó‚ÇÄ()
        return (ŒΩ, x)
    end

    return solve_by_proj_conj_grad()
end

# Assumptions:
# constrained space ‚â† ‚àÖ
# If this is not guaranteed, add a check - it should return nothing by now :)
# Usage (example):  
# xÃÑ, Œº, L, ‚àáLÃÑ = solve_quadratic_min_flow(ùîì=ùîì, Œº=zeros(Float64, 2), Œµ=1e-12, œµ=1e-12, reset‚ÇÄ=Inf)
function solve_quadratic_min_flow_d1(; ùîì, Œº, Œµ=1e-12, œµ=1e-12, œµ‚Çò=1e-12, reset‚ÇÄ=Inf, max_iter=5000, reduce=false, verb=0)
    # verbosity utility
    function verba(level, message)
        if level ‚â§ verb
            println(message)
        end
    end

    Q, q, l, u, E, b = (ùîì.Q, ùîì.q, ùîì.l, ùîì.u, ùîì.E, ùîì.b)

    Q_diag = view(Q, [CartesianIndex(i, i) for i in 1:size(Q, 1)])
    ùîé = Q_diag .< œµ‚Çò
    Œª_min = minimum(Q_diag[.~ùîé])

    # reduce == true ‚üπ assume E represent a connected graph
    if reduce == true
        E, b, Œº = E[1:end-1, :], b[1:end-1], Œº[1:end-1]
    end
    m, n = size(E)      # m: number 

    QÃÉ = spzeros(eltype(Q), size(Q, 1), size(Q, 2))
    QÃÉ_diag = view(QÃÉ, [CartesianIndex(i, i) for i in 1:size(Q, 1)])
    QÃÉ_diag[:] = 1. ./ Q_diag

    Ql, Qu = Q*l, Q*u

    # 0 attractor
    to0 = x::AbstractFloat -> (abs(x) ‚â• œµ‚Çò ? x : 0.)
    a::AbstractFloat ‚âà b::AbstractFloat = (1+œµ‚Çò*sign(a))*a ‚â• (1-œµ‚Çò*sign(b))*b && (1+œµ‚Çò*sign(b))*b ‚â• (1-œµ‚Çò*sign(a))*a

    function get_L(x, Œº)
        return 0.5*x'*Q*x + q'*x + Œº'*(E*x-b)
    end
    # xÃÉ = argmin‚Çì L(x, Œº) without box constraints
    function get_QxÃÉ(Œº)
        verba(3, "get_QxÃÉ: QxÃÉ=$(to0.(-E'*Œº-q))")
        return to0.(-E'*Œº-q) #(a -> abs(a)>œµ‚Çò ? a : 0).(-E'*Œº-q)
    end
    # ‚úì
    function get_QxÃÉ(ŒºÃÑ, ùîÖ)
        return to0.(-E[:, ùîÖ[:, 2]]'*ŒºÃÑ -q[ùîÖ[:, 2]]) #   -E[:, ùîÖ[:, 2]]'*ŒºÃÑ -q[ùîÖ[:, 2]] #
    end
    # xÃÖ = argmin‚Çì L(x, Œº) beholding box constraints l .<= x .<= u
    function get_xÃÖ(Œº)
        return [ maximum([min(u[i], (-Œº'*E[:, i]-q[i]) / Q[i, i]), l[i]]) for i=1:n ]
    end
    # mark if x is on a side of the box constraints
    # 1 -> lower  2 -> interior  3 -> upper
    function on_box_side!(QxÃÉ, ùîÖ)
        # add _œµ maybe 
        ùîÖ[:, 1] .= (QxÃÉ .‚â§ Ql)
        ùîÖ[:, 3] .= (QxÃÉ .‚â• Qu) .& (.~ùîÖ[:, 1])
        ùîÖ[:, 2] .= .~(ùîÖ[:, 1] .| ùîÖ[:, 3])
        return ùîÖ
    end
    function get_xÃÖ(QxÃÉ, ùîÖ)
        return sum([ùîÖ[:, 1].*l, ùîÖ[:, 2].*(QÃÉ*QxÃÉ), ùîÖ[:, 3].*u])
    end
    # ‚àáL with respecto to Œº, that is the constraint E*x(Œº)-b
    function get_‚àáL(x)
        return E*x-b
    end
    # ‚úì
    function get_Œ±ÃÑs(QxÃÉ, E·µÄd)
        # 1 : getting inside
        # 2 : going outside
        Œ±ÃÑs = zeros(eltype(E·µÄd), size(E·µÄd, 1), 2)

        ùî© = [E·µÄd .< 0  E·µÄd .> 0]        
        Œ±ÃÑs[ùî©] = ([QxÃÉ QxÃÉ][ùî©] - [Ql Ql][ùî©]) ./ [E·µÄd E·µÄd][ùî©]
        ùî©[ùî©] = ùî©[ùî©] .& (Œ±ÃÑs[ùî©] .‚â• -100*œµ‚Çò)

        ùî≤ = [E·µÄd .> 0  E·µÄd .< 0]
        Œ±ÃÑs[ùî≤] = ([QxÃÉ QxÃÉ][ùî≤] - [Qu Qu][ùî≤]) ./ [E·µÄd E·µÄd][ùî≤]
        ùî≤[ùî≤] = ùî≤[ùî≤] .& (Œ±ÃÑs[ùî≤] .‚â• -100*œµ‚Çò)

        return (Œ±ÃÑs, ùî©, ùî≤)
    end
    # ‚úì (todo)
    function get_Œ±ÃÑs(QxÃÉ, E·µÄd, ùîÖ)
        # 1 : getting inside
        # 2 : going outside
        Œ±ÃÑs = zeros(eltype(E·µÄd), size(E·µÄd, 1), 2)

        ùî© = [E·µÄd .< 0  E·µÄd .> 0]        
        Œ±ÃÑs[ùî©] = ([QxÃÉ QxÃÉ][ùî©] - [Ql Ql][ùî©]) ./ [E·µÄd E·µÄd][ùî©]
        ùî©[ùî©] = ùî©[ùî©] .& (Œ±ÃÑs[ùî©] .‚â• -œµ‚Çò)

        ùî≤ = [E·µÄd .> 0  E·µÄd .< 0]
        Œ±ÃÑs[ùî≤] = ([QxÃÉ QxÃÉ][ùî≤] - [Qu Qu][ùî≤]) ./ [E·µÄd E·µÄd][ùî≤]
        ùî≤[ùî≤] = ùî≤[ùî≤] .& (Œ±ÃÑs[ùî≤] .‚â• -œµ‚Çò)

        return (Œ±ÃÑs, ùî©, ùî≤)
    end
    # ‚úì
    function sortperm_Œ±ÃÑs(Œ±ÃÑs, ùî©, ùî≤)
        P = findall(ùî© .| ùî≤)
        return sort!(P, lt = (i, j) -> begin
            if Œ±ÃÑs[i] ‚âà Œ±ÃÑs[j]
                (i[2], Œ±ÃÑs[i], i[1]) < (j[2], Œ±ÃÑs[j], j[1])
            else
                Œ±ÃÑs[i] < Œ±ÃÑs[j]            
            end
        end)
    end
    # ‚úì
    function exact_line_search!(x, Œº, d, ùîÖ)
        E·µÄŒº, E·µÄd, d·µÄb, QxÃÉ = E'*Œº, E'*d, d'*b, get_QxÃÉ(Œº)
        Œ±ÃÑs, ùî©, ùî≤ = get_Œ±ÃÑs(QxÃÉ, E·µÄd)
        function filter_inconsistent(P)
            in = ùîÖ[:, 2]
            verba(4, "filter_inconsistent: siamo nelle regioni $(findall(in))")
            verba(4, "filter_inconsistent: unfiltered=$([(p[1], p[2]) for p in P])")
            remove = zeros(Bool, size(P, 1))
            for i in 1:size(P, 1)
                p = P[i]
                if in[p[1]] == (p[2] == 1)
                    remove[i] = true
                    continue
                end
                in[p[1]] = (p[2] == 1)
            end
            verba(4, "filter_inconsistent: filtered=$([(p[1], p[2]) for p in P[.~remove]])")
            return P[.~remove]
        end
        P_Œ±ÃÑs = filter_inconsistent(sortperm_Œ±ÃÑs(Œ±ÃÑs, ùî©, ùî≤))
        verba(3, "exact_line_search: Œ±s=$(Œ±ÃÑs[P_Œ±ÃÑs])")

        # x(Œº) is NaN when it is not a function, so pick the best representative
        function resolve_nan!(x)
            ùî´ = isnan.(x)
            if any(ùî´)
                verba(2, "resolve_nan: resolving NaN in x=$x")
                Inc = E·µÄd[ùî´] .> 0
                Dec = E·µÄd[ùî´] .< 0
                Nul = E·µÄd[ùî´] .== 0
                LÃÇ, UÃÇ = Inc.*l[ùî´] + Dec.*u[ùî´], Inc.*u[ùî´] + Dec.*l[ùî´]
                S = d·µÄb - E·µÄd[.~ùî´]'*x[.~ùî´]
                Œª = (S - E·µÄd[ùî´]'*LÃÇ) / (E·µÄd[ùî´]'*(UÃÇ-LÃÇ))
                if 0 ‚â§ Œª ‚â§ 1
                    x[ùî´] = LÃÇ + Œª*(UÃÇ - LÃÇ) + Nul.*(l[ùî´]+u[ùî´]) / 2
                    verba(2, "resolve_nan: resolved x=$x")
                    return true
                else
                    x[ùî´] = Nul.*(l[ùî´]+u[ùî´]) / 2 + ((Œª > 1) ? UÃÇ : LÃÇ)
                    verba(2, "resolve_nan: UNresolved x=$x")
                    return false
                end
            end
            return nothing
        end

        function find_Œ±!(Œº, x, Œ±‚ÇÄ, Œ±‚ÇÅ)
            if any(ùîÖ[:, 2])
                verba(3, "find_Œ±: siamo nelle regioni $(findall(ùîÖ[:, 2]))")
                ŒîŒ± = (E·µÄd'*x - d·µÄb) / (E·µÄd[ùîÖ[:, 2]]' * QÃÉ[ùîÖ[:, 2], ùîÖ[:, 2]] * E·µÄd[ùîÖ[:, 2]])
                verba(3, "find_Œ±: ŒîŒ± = $(ŒîŒ±)")
                if isnan(ŒîŒ±)
                    ŒîŒ± = 0
                end
                if 0 ‚â§ ŒîŒ± ‚â§ Œ±‚ÇÅ-Œ±‚ÇÄ
                    Œº[:] = Œº + (Œ±‚ÇÄ+ŒîŒ±)*d
                    x[:] = get_xÃÖ(get_QxÃÉ(Œº), ùîÖ)
                    verba(3, "find_Œ±: Œº=$Œº \nfind_Œ±: QxÃÉ=$(get_QxÃÉ(Œº)) \nfind_Œ±: x=$x")
                    return true
                end
                verba(3, "find_Œ±: ŒîŒ± is outside of this region")
            end
            return false
        end

        Œ±ÃÑ, ŒºÃÑ  = 0., copy(Œº)
        j = 1
        last_j = size(P_Œ±ÃÑs, 1)
        while j ‚â§ last_j
            ŒºÃÑ[:] = Œº
            i = P_Œ±ÃÑs[j]
            found_Œ± = find_Œ±!(ŒºÃÑ, x, Œ±ÃÑ, Œ±ÃÑs[i])
            if found_Œ±
                resolved_nan = resolve_nan!(x)
                if resolved_nan === true || resolved_nan === nothing
                    Œº[:] = ŒºÃÑ
                    return
                end
            end

            # set ùîÖ for next Œ±ÃÑ
            k = j
            while (k ‚â§ last_j) && (P_Œ±ÃÑs[k][2] == P_Œ±ÃÑs[j][2]) && (Œ±ÃÑs[P_Œ±ÃÑs[k]] ‚âà Œ±ÃÑs[P_Œ±ÃÑs[j]])
                verba(4, "exact_line_search: cross border of region $(P_Œ±ÃÑs[k])")
                verba(4, "exact_line_search: dalle regioni $(findall(ùîÖ[:, 2]))")
                P_Œ±ÃÑs[k] |> ii -> begin
                    ùîÖ[ii[1], :] = (ii[2] == 2) ? [ùî©[ii] false ùî≤[ii]] : [false true false]
                    Œ±ÃÑ = Œ±ÃÑs[ii]
                end
                verba(4, "exact_line_search: alle regioni $(findall(ùîÖ[:, 2]))")
                k += 1
            end
            verba(4, "exact_line_search: ALLA FINE DEL GRUPPO $(findall(ùîÖ[:, 2]))")

            j = k
            ŒºÃÑ[:]  = Œº + Œ±ÃÑ*d
            QxÃÉ[ùîÖ[:, 2]] = get_QxÃÉ(ŒºÃÑ, ùîÖ)
            x[ùîÖ[:, 2]] = max.(min.(QÃÉ[ùîÖ[:, 2], ùîÖ[:, 2]]*QxÃÉ[ùîÖ[:, 2]], u[ùîÖ[:, 2]]), l[ùîÖ[:, 2]])
        end
        ŒºÃÑ[:] = Œº
        found_Œ± = find_Œ±!(ŒºÃÑ, x, Œ±ÃÑ, Inf)
        if found_Œ±
            resolved_nan = resolve_nan!(x)
            if resolved_nan === true || resolved_nan === nothing
                Œº[:] = ŒºÃÑ
                return
            end
        end
    end

    function solve()
        # Reach iteratively the singular Q
        Œª = Œª_min
        function update_Œª(Œª‚Ä≤)
            Œª = Œª‚Ä≤
            Q_diag[ùîé] .= Œª
            QÃÉ_diag[ùîé] .= 1. / Œª
            Qu[ùîé], Ql[ùîé] = Q_diag[ùîé] .* u[ùîé], Q_diag[ùîé] .* l[ùîé]
        end
        update_Œª(Œª/10.)

        Ls = []
        norm‚àáLs = []
        QxÃÉ = get_QxÃÉ(Œº)
        ùîÖ = zeros(Bool, size(E, 2), 3)
        on_box_side!(QxÃÉ, ùîÖ)
        xÃÖ = get_xÃÖ(QxÃÉ, ùîÖ)

        while any(isnan.(xÃÖ))
            verba(2, "solve: perturbing the starting Œº to avoid NaNs")
            Œº[:] += Œµ*(rand(eltype(Œº), size(Œº, 1))-0.5)
            QxÃÉ[:] = get_QxÃÉ(Œº)
            ùîÖ[:, :] = zeros(Bool, size(E, 2), 3)
            on_box_side!(QxÃÉ, ùîÖ)
            xÃÖ[:] = get_xÃÖ(QxÃÉ, ùîÖ)
        end

        ‚àáL = get_‚àáL(xÃÖ)
        norm‚àáL = norm(‚àáL) 
        norm‚àáLs = [norm‚àáLs; norm‚àáL]
        Ls = [Ls; get_L(xÃÖ, Œº)]
        verba(1, "solve: |‚àáL| = $(norm‚àáL) \nsolve: L = $(get_L(xÃÖ, Œº))\n")
        d = copy(‚àáL)
        ‚àáL‚ÇÄ = copy(‚àáL)
        reset = reset‚ÇÄ
        counter = 0
        while (norm‚àáL ‚â• Œµ) # && (L-L‚ÇÄ ‚â• Œµ*abs(L))
            if norm‚àáL < Œª
                update_Œª(Œª / 1.2)
            end
            exact_line_search!(xÃÖ, Œº, d, ùîÖ)
            verba(2, "solve: Œº=$Œº\nsolve: x=$xÃÖ")
            ‚àáL‚ÇÄ, ‚àáL = ‚àáL, get_‚àáL(xÃÖ)
            norm‚àáL = norm(‚àáL)
            verba(4, "solve: d·µÄ‚àáL = $(d'‚àáL)")
            reset = reset-1
            d[:] = ‚àáL + d*(‚àáL'*‚àáL - ‚àáL'*‚àáL‚ÇÄ) / (‚àáL‚ÇÄ'*‚àáL‚ÇÄ)
            if d'*‚àáL < 0
                d[:] = ‚àáL
            end
            verba(3, "solve: d=$d")
            # d[:] = ‚àáL
            #d[:] += 1000*Œµ*(-0.5 .+ rand(size(d, 1)))
            verba(1, "solve: |‚àáL| = $(norm‚àáL) \nsolve: L = $(get_L(xÃÖ, Œº))\n")
            norm‚àáLs = [norm‚àáLs; norm‚àáL]
            Ls = [Ls; get_L(xÃÖ, Œº)]
            counter += 1
            if counter == max_iter
                break
            end
        end

        L = get_L(xÃÖ, Œº)
        verba(0, "solve: L = $L")
        verba(0, "\nsolve: $counter iterazioni\n")
        return (xÃÖ, Œº, L, ‚àáL, Ls, norm‚àáLs, Œª)
    end

    return solve()
end

using Plots
function test(;solver, singular, maxiter, m, n, ùîì=nothing, reduce=false, verb=1, Œµ=1e-8)
    if ùîì === nothing
        ùîì = generate_quadratic_min_cost_flow_boxed_problem(Float64, m, n, sing=singular)
        if reduce == true
            ùîì = reduce_quadratic_problem(ùîì)[1]
        end
    end

    Q, q, l, u, E, b = (ùîì.Q, ùîì.q, ùîì.l, ùîì.u, ùîì.E, ùîì.b)
    xÃÑ, Œº, L, ‚àáL, Ls, norms, Œª = solver(ùîì=ùîì, Œº=zeros(Float64, size(E, 1)),  max_iter=maxiter, Œµ=Œµ, œµ=1e-25, reduce=reduce, verb=verb)
    p = plot(1:size(Ls, 1), Ls)
    plot!(p, 1:size(norms, 1), norms)
    return p, ùîì, Œª
end

function reduce_quadratic_problem(ùîì::quadratic_min_cost_flow_boxed_problem)
    Q, q, l, u, E, b = (ùîì.Q, ùîì.q, ùîì.l, ùîì.u, ùîì.E, ùîì.b)
    P_row, P_col = get_graph_components(E)
    return [reduced_qmcfbp(Q[p_col, p_col], q[p_col], l[p_col], u[p_col], E[p_row, p_col], b[p_row]) for (p_row, p_col) in zip(eachcol(P_row), eachrow(P_col))]
end

# For the specific case when E is the incidence matrix of a graph, 
# the problem is separable in the subproblems corresponding to the
# connected components, calculated hereafter as bitmasks on the nodes
# E : node-arc incidence matrix
function get_graph_components(E)
    # m : number of nodes
    # n : number of arcs
    m, n = size(E)
    M = E .‚â† 0
    B = zeros(Bool, m)
    P = zeros(Bool, m, 0)
    P_C = zeros(Bool, 0, n)
    for i in 1:m
        if B[i] == true
            continue
        end
        
        P = cat(P, zeros(Bool, m), dims=2)
        P_C = cat(P_C, zeros(Bool, 1, n), dims=1)

        B[i] = true
        P[i, end] = true

        V·µ¢ = begin
            P_C[end, :] = M[i, :]
            N = M[:, M[i, :]]
            if size(N, 2) == 0
                zeros(Bool, m)
            else
                V = (.~(B)) .& reduce((a, b) -> a .| b, [N[:, i] for i in 1:size(N, 2)])
                B .|= V
                V
            end
        end
        
        if any(V·µ¢) == false
            continue
        end

        P[:, end] .|= V·µ¢
        stack = findall(V·µ¢)

        j = 1
        while j ‚â§ size(stack, 1)
            V‚±º = begin
                P_C[end, :] .|= M[stack[j], :]
                N = M[:, M[stack[j], :]]
                if size(N, 2) == 0
                    zeros(Bool, m)
                else
                    V = (.~(B)) .& reduce((a, b) -> a .| b, [N[:, k] for k in 1:size(N, 2)])
                    B .|= V
                    V
                end
            end    
            j += 1
            if any(V‚±º) == false
                continue
            end
            
            P[:, end] .|= V‚±º
            append!(stack, findall(V‚±º))
        end
    end

    return (P, P_C)
end