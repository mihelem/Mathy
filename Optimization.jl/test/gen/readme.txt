Author: Claudio Gentile
Date: 20-03-2012

The generation of the Single Commodity Convex Quadratic-cost Network Design
Problems is performed in three steps:

1) pargen generates parameters for the netgen generator.

   usage is

   pargen m rho k cf cq s

   where

   m    is the number of edges of network G to be generated

   rho  in the set {1,2,3} represent the density of G according to
        the following formulae: let

       	   prho = 0.25 if rho = 1
	   prho = 0.5  if rho = 2
	   prho = 0.75 if rho = 3

        then the number of nodes is

           n =  floor( 1.0 + sqrt( 1.0 + (8.0*m)/prho ) ) / 2 )

   k    is the number of the instance

   cf   is equal either to "a" or to "b"; used in step 3

   cq   is equal either to "a" or to "b"; used in step 3

   scale is either "s" or "ns"; if scale == "s", capacities of arcs are
         scaled by 0.7

   pargen produces a file named

         netgen-$m-$rho-$k-$cf-$cq-$s.par


2)  netgen is a well-known generator [A] of single-commodity Min-Cost Flow
    Problems, available e.g. at

       http://www.di.unipi.it/optimize/Data/MMCF/netgen.tgz

    or at the DIMACS site

       ftp://dimacs.rutgers.edu/pub/netflow/generators/

    Usage is

       netgen < netgen-$m-$rho-$k-$cf-$cq-$s.par \
              > netgen-$m-$rho-$k-$cf-$cq-$s.dmx

    where the values m,rho,k,cf,cq,s are the same as in step 1).


3)  qfcgen produces the cost file for fixed and quadratic costs.
    Usage is

       qfcgen netgen-$m-$rho-$k-$cf-$cq-$s.dmx

    Output is a file

       netgen-$m-$rho-$k-$cf-$cq-$s.qfc

    that contains

       m (the number of arcs as given in input)
       fixed costs of arc 1 ... fixed costs of arc m
       quadratic cost of arc 1 ... quadratic cost of arc m

    The parameter cf indicates if the fixed costs are generated to be
    high ("a") or low ("b") with respect to the linear costs generated by
    netgen. The parameter cq indicates if the quadratic costs are generated
    to be high ("a") or low ("b") with respect to the fixed costs.
    The formulae are the following:

    Fixed Costs

    Ccm_1 = cf == 'a' ?  3.0 : 0.5;
    Ccm_2 = cf == 'a' ? 10.0 : 1.0;

    Let Cb be the linear costs: then the fixed costs Cc are

    num1 = Cb[ e ] * Ccm_1;
    num2 = Cb[ e ] * Ccm_2 - num1;
    num = rand() % num2 + num1;
    Cc[ e ] = num + 1;

    Quadratic Costs

    Cam_1 = cf == 'a' ?  100 : 1;
    Cam_2 = cf == 'a' ? 1000 : 3;

    With Cc the fixed costs computed as above, the quadratic costs Ca are

    dnum1 = Cc[ e ] * Cam_1;
    diff = Cc[ e ] * Cam_2 - dnum1;
    num = ( ( (double)rand() ) / RAND_MAX ) * diff;
    num = num + dnum1;
    Ca[ e ] = num + 1;


[A] Klingman, D., A. Napier, and J. Stutz, "NETGEN: A Program for Generating
    Large Scale Capacitated Assignment, Transportation, and Minimum Cost Flow
    Network Problems", Management Science 20, 5, 814-821 (1974)


--------------------

(*** See the end of this file for a description of some fixes to standard
  NETGEN bugs in c and in Fortran versions)

netgen.shell:  NETGEN is described in Klingman, Napier, and Stutz,
             ``NETGEN: A program for generating large scale capacitated
              assignment, transportation, and minimum-cost flow network
              problems,'' Management Science 20, 814-820 (1974).

               This is a Unix shell containing a version of NETGEN written
               in C.  Contributed by Norbert Schlenker.  Some copywrite
               restrictions apply---read the in-file comments.

               To use, you just need to obtain and execute netgen.shell
               (using /bin/sh (not csh)).  This  will create a Makefile
               and other necessary files.  The compiler switches are
               set for the DIMACS input/output format.

problems      Input commands for the 40 NETGEN benchmark problems.



netgen: example format of input data
1	seed>0
1	problem > 0
400	nodes
200	sources
200	sinks
5000	density
-1000	mincost
+1000	maxcost
100000	supply
150	tsources
150	tsinks
20	hicost%
100	capacitated%
-1000	mincap
+1000	maxcap

Date: Fri, 13 Mar 92 18:44:59 PST
From: Michael Kharitonov <misha@Jinn.Stanford.EDU>
To: cheriyan@cs.cornell.edu
Subject: Netgen problems
Status: RO

Hi. I was wondering if you managed to generate instances with
netgen that have 2^17 nodes or more. Even after I changed the
corresponding parameters, both C and Fortran versions of
netgen do not terminate or produce any output when given the
following input:

13502460 17161 131072 8192 8192 1048576 0 4096 67108864 0 0 100 100 1 16384

I would really appreciate any light you can shed on this problem.

Thanks,
Michael


From cheriyan Wed Mar 18 16:00:21 1992
To: misha@Jinn.Stanford.EDU
Subject: Re:  Netgen problems
Cc: cheriyan
Status: R

Michael,

The "bug" in the C version of NETGEN is as follows:
At some statements, the program multiplies two values that
may be as big as n, the no. of nodes. So, if you have
n > 2^{15} there is danger of overflow, assuming 32-bit integers.
In the instance you sent, there is indeed an integer overflow,
causing the program to loop endlessly.

Here is a quick fix.

In line 265 of the "netgen.c" file (in procedure "netgen")
replace
sinks_per_source = 2*sort_count*SINKS/(NODES-SOURCES-SINKS);

by
sinks_per_source = ((double) 2*sort_count*SINKS) / ((double) NODES-SOURCES-SINKS);


and also in line 433 in the same file (in procedure "pick_head")
replace

     } while (nodes_left * (non_sources - 1) < remaining_arcs - limit);
by

     } while ( ((double) nodes_left * (non_sources - 1)) < ((double) remaining_arcs - limit));


This fix makes your instance go through NETGEN (C version).
Without the fix, there is overflow at line 433,
and the program gets stuck forever in a "while" loop
in procedure "pick_head".
Here is the timing data for the revised NETGEN on a sparc-2:

time gnetgen < misha >! misha.min

192.8u 15.2s 10:00 34% 0+10704k 3+3413io 2844pf+0w

Probably, this fix will work fine for all your networks.
Unfortunately, the fact is that NETGEN was not intended for such big instances.
In order to guarantee that the program will always
work fine for "big instances", the only way seems to be
to go carefully through the entire program,
and mark all potential overflows and then rectify them,
eg., by using (double).

Also, the FORTRAN version has exactly the same "bugs" --
so it won't work unless a similar fix is used.


Best wishes,
-Joseph
